# Copyright (c) 2025-2026 Datalayer, Inc.
# Distributed under the terms of the Modified BSD License.

"""
FastAPI routes for MCP Tool Proxy.

This module provides an HTTP endpoint that allows remote sandboxes (e.g., Jupyter
kernels in separate containers) to call MCP tools running in the agent-runtimes
container via stdio.

Architecture Overview (Two-Container Codemode):

```
When running in a Kubernetes environment with separate containers:

┌──────────────────────────────────────────────────────────────────────────────┐
│  agent-runtimes container (port 8765)                                        │
│  ┌─────────────────────┐    ┌──────────────────────────────────────────────┐ │
│  │  MCP Servers (stdio)│◀───│  /api/v1/mcp/proxy/{server}/{tool}           │ │
│  │  - github           │    │  - Receives HTTP POST from Jupyter kernel     │ │
│  │  - filesystem       │    │  - Routes to appropriate stdio MCP server     │ │
│  │  - tavily           │    │  - Returns tool result as JSON                │ │
│  └─────────────────────┘    └────────────────────▲─────────────────────────┘ │
│                                                   │ HTTP POST                 │
└───────────────────────────────────────────────────┼──────────────────────────┘
                                                    │
         ┌──────────────────────────────────────────┘
         │
         ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│  jupyter container (port 2300)                                                │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │  Jupyter Server + Kernel                                                │  │
│  │  - Executes generated Python code                                       │  │
│  │  - `from generated.mcp.github import star_repo`                     │  │
│  │  - `result = await star_repo(owner="datalayer", repo="ui")`            │  │
│  │  - Generated code calls HTTP proxy instead of stdio                     │  │
│  │                                                                          │  │
│  │  /mnt/shared-agent/generated/  (shared emptyDir volume)                 │  │
│  │  └── servers/                                                            │  │
│  │      └── github.py  ─────────────────────────────────────────────────┐  │  │
│  │                     │  async def star_repo(...):                     │  │  │
│  │                     │      # Calls HTTP proxy at agent-runtimes:8765 │  │  │
│  │                     │      return await http_call_tool(...)          │  │  │
│  │                     └────────────────────────────────────────────────┘  │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────────────────┘

The shared volume (/mnt/shared-agent) contains:
- generated/  - Python bindings generated by agent-runtimes, read by Jupyter kernel
- skills/     - User-created skills, accessible from both containers
```

This module provides the `/api/v1/mcp/proxy/*` endpoints that bridge the gap
between the remote Jupyter sandbox and the local stdio MCP servers.
"""

import logging
from typing import Any

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel

from agent_runtimes.mcp.lifecycle import get_mcp_lifecycle_manager

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/mcp/proxy", tags=["mcp-proxy"])

# ---------------------------------------------------------------------------
# Skills proxy caller registry
# ---------------------------------------------------------------------------
# When skills are wired into codemode, a callback is registered here so that
# remote sandboxes can call skills via the same HTTP proxy mechanism.
# The callback signature is: async (tool_name: str, arguments: dict) -> Any

_skills_proxy_caller: Any = None


def set_skills_proxy_caller(caller: Any) -> None:
    """Register a callable for proxying skill tool calls from remote sandboxes."""
    global _skills_proxy_caller
    _skills_proxy_caller = caller
    logger.info("[MCP Proxy] Skills proxy caller registered")


def get_skills_proxy_caller() -> Any:
    """Return the currently registered skills proxy caller (or *None*)."""
    return _skills_proxy_caller


class ToolCallRequest(BaseModel):
    """
    Request body for tool calls.

    Attributes:
        arguments: The arguments to pass to the tool.
    """

    arguments: dict[str, Any]


class ToolCallResponse(BaseModel):
    """
    Response from a tool call.

    Attributes:
        success: Whether the tool call succeeded.
        result: The result data from the tool (if successful).
        error: Error message (if failed).
        is_error: Whether the MCP response indicates an error.
    """

    success: bool
    result: Any = None
    error: str | None = None
    is_error: bool = False


@router.post("/{server_name}/tools/{tool_name}", response_model=ToolCallResponse)
async def proxy_tool_call(
    server_name: str,
    tool_name: str,
    request: ToolCallRequest,
) -> ToolCallResponse:
    """
    Proxy a tool call from a remote sandbox to a local MCP server.

    This endpoint allows code running in a remote Jupyter kernel to call
    tools on MCP servers that are running as stdio subprocesses in the
    agent-runtimes container.

    The flow is:
    1. Jupyter kernel generates: `await github__star_repo(owner="x", repo="y")`
    2. Generated code sends HTTP POST to: /api/v1/mcp/proxy/github/tools/star_repo
    3. This endpoint finds the 'github' MCP server instance
    4. Calls the 'star_repo' tool via the MCP stdio session
    5. Returns the result as JSON

    Args:
        server_name: Name of the MCP server (e.g., 'github', 'filesystem').
        tool_name: Name of the tool to call (e.g., 'star_repo', 'list_dir').
        request: The tool call arguments.

    Returns:
        ToolCallResponse with the result or error.
    """
    logger.info(f"[MCP Proxy] Proxying tool call: {server_name}__{tool_name}")
    logger.debug(f"[MCP Proxy] Arguments: {request.arguments}")

    # ------------------------------------------------------------------
    # Skills pseudo-server: route to the registered skills proxy caller
    # ------------------------------------------------------------------
    if server_name == "skills":
        caller = get_skills_proxy_caller()
        if caller is None:
            raise HTTPException(
                status_code=404,
                detail="Skills proxy caller not registered — skills are not enabled for this agent.",
            )
        try:
            result = await caller(f"skills__{tool_name}", request.arguments)
            return ToolCallResponse(success=True, result=result)
        except Exception as exc:
            logger.error(f"[MCP Proxy] Skills call failed: {exc}", exc_info=True)
            return ToolCallResponse(success=False, error=str(exc))

    try:
        lifecycle_manager = get_mcp_lifecycle_manager()

        # Try to find the server in both config and catalog storage
        # First try catalog (most common for codemode), then config
        instance = lifecycle_manager.get_running_server(server_name, is_config=False)
        if instance is None:
            instance = lifecycle_manager.get_running_server(server_name, is_config=True)

        if instance is None:
            # List available servers for debugging
            all_servers = lifecycle_manager.get_all_running_servers()
            available = [s.server_id for s in all_servers]
            logger.error(
                f"[MCP Proxy] Server '{server_name}' not found. Available: {available}"
            )
            raise HTTPException(
                status_code=404,
                detail=f"MCP server '{server_name}' is not running. Available servers: {available}",
            )

        # Get the pydantic MCP server instance
        pydantic_server = instance.pydantic_server
        if pydantic_server is None:
            raise HTTPException(
                status_code=500,
                detail=f"MCP server '{server_name}' has no active session",
            )

        # Call the tool via the pydantic MCP server
        # The tool name in the server uses the prefix format: {server_id}_{tool_name}
        # But we need to call with the original tool name
        logger.info(f"[MCP Proxy] Calling tool '{tool_name}' on server '{server_name}'")

        try:
            # Use direct_call_tool which doesn't require a RunContext
            # This is the preferred method for proxy calls
            if hasattr(pydantic_server, "direct_call_tool"):
                result = await pydantic_server.direct_call_tool(
                    tool_name, request.arguments
                )

                # Parse the MCP response - ToolResult has content and is_error
                if hasattr(result, "model_dump"):
                    result_dict = result.model_dump(by_alias=True, exclude_none=True)
                elif hasattr(result, "__dict__"):
                    result_dict = result.__dict__
                else:
                    result_dict = {"content": result}

                # Handle both is_error (Python) and isError (JSON alias)
                is_error = result_dict.get(
                    "is_error", result_dict.get("isError", False)
                )
                content = result_dict.get("content", [])

                # Extract text content from MCP response format
                if isinstance(content, list):
                    # MCP content is typically a list of content blocks
                    text_parts = []
                    for item in content:
                        if isinstance(item, dict) and item.get("type") == "text":
                            text_parts.append(item.get("text", ""))
                        elif isinstance(item, str):
                            text_parts.append(item)
                        elif hasattr(item, "text"):
                            text_parts.append(item.text)
                    result_data = "\n".join(text_parts) if text_parts else content
                else:
                    result_data = content

                logger.info(f"[MCP Proxy] Tool call succeeded: {tool_name}")
                return ToolCallResponse(
                    success=not is_error,
                    result=result_data,
                    is_error=is_error,
                    error=str(result_data) if is_error else None,
                )
            else:
                # Fallback: pydantic_server doesn't have direct_call_tool
                raise HTTPException(
                    status_code=500,
                    detail=f"MCP server '{server_name}' does not support direct_call_tool",
                )

        except Exception as call_error:
            logger.error(f"[MCP Proxy] Tool call failed: {call_error}", exc_info=True)
            return ToolCallResponse(
                success=False,
                error=str(call_error),
            )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[MCP Proxy] Unexpected error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/servers")
async def list_proxy_servers() -> dict[str, Any]:
    """
    List available MCP servers that can be proxied.

    Returns:
        Dictionary with list of available servers and their tools.
    """
    try:
        lifecycle_manager = get_mcp_lifecycle_manager()
        all_servers = lifecycle_manager.get_all_running_servers()

        servers = []
        for instance in all_servers:
            server_info = {
                "id": instance.server_id,
                "name": instance.config.name,
                "is_config": instance.config.is_config,
                "is_running": instance.is_running,
                "tools": [
                    {
                        "name": tool.name,
                        "description": tool.description,
                    }
                    for tool in instance.tools
                ],
            }
            servers.append(server_info)

        return {
            "servers": servers,
            "total": len(servers),
        }

    except Exception as e:
        logger.error(f"[MCP Proxy] Error listing servers: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/health")
async def proxy_health() -> dict[str, str]:
    """
    Health check for the MCP proxy endpoint.

    Returns:
        Health status.
    """
    return {"status": "ok"}
